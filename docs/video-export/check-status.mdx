---
title: "Check Export Status"
description: "Monitor export progress and download completed videos"
---

## Overview

After starting a video export, use the status endpoint to monitor progress and retrieve the download URL when the export completes. This guide covers efficient polling strategies and download handling.

## Basic Status Check

Check the status of an export job using the job ID returned from the export start endpoint:

```python
import requests

def check_export_status(job_id):
    """Check the status of an export job"""
    response = requests.get(
        f'https://api.hoox.video/v1/export/status/{job_id}',
        headers={'Authorization': 'Bearer your_api_key'}
    )
    
    if response.status_code == 200:
        return response.json()
    else:
        print(f"Error checking status: {response.json()}")
        return None

# Usage
status = check_export_status('export_abcd1234')
print(f"Export status: {status['status']}")
```

## Status Response Structure

The status endpoint returns different information depending on the export state:

### Pending/Processing Status
```json
{
  "job_id": "export_abcd1234",
  "status": "processing",
  "progress": 45,
  "current_step": "Encoding video"
}
```

### Completed Status
```json
{
  "job_id": "export_abcd1234",
  "status": "completed",
  "progress": 100,
  "current_step": "Export complete",
  "result": {
    "video_url": "https://storage.hoox.video/exports/export_abcd1234.mp4",
    "thumbnail_url": "https://storage.hoox.video/thumbnails/vid_xyz789.jpg",
    "cost": 0,
    "created_at": "2024-01-15T10:35:00Z"
  }
}
```

### Failed Status
```json
{
  "job_id": "export_abcd1234",
  "status": "failed",
  "progress": 30,
  "current_step": "Export failed",
  "error": {
    "code": "ENCODING_FAILED",
    "message": "Failed to encode video in the requested format"
  }
}
```

## Polling Strategies

### 1. Simple Polling Loop

Basic implementation that checks status until completion:

```python
import time

def wait_for_export_completion(job_id, max_wait=300):
    """Wait for export to complete with simple polling"""
    start_time = time.time()
    
    while time.time() - start_time < max_wait:
        status_data = check_export_status(job_id)
        
        if not status_data:
            return None
            
        status = status_data['status']
        progress = status_data.get('progress', 0)
        step = status_data.get('current_step', 'Unknown')
        
        print(f"Export {job_id}: {status} ({progress}%) - {step}")
        
        if status == 'completed':
            return status_data['result']['video_url']
        elif status == 'failed':
            error = status_data.get('error', {})
            raise Exception(f"Export failed: {error.get('message', 'Unknown error')}")
        
        time.sleep(5)  # Wait 5 seconds before next check
    
    raise TimeoutError(f"Export did not complete within {max_wait} seconds")

# Usage
try:
    video_url = wait_for_export_completion('export_abcd1234')
    print(f"Export completed! Download URL: {video_url}")
except Exception as e:
    print(f"Export failed: {e}")
```

### 2. Exponential Backoff Polling

More efficient polling that reduces API calls over time:

```python
def wait_for_export_with_backoff(job_id, max_wait=300):
    """Wait for export with exponential backoff polling"""
    start_time = time.time()
    wait_interval = 3  # Start with 3 seconds
    max_interval = 15  # Maximum wait between polls
    
    while time.time() - start_time < max_wait:
        status_data = check_export_status(job_id)
        
        if not status_data:
            return None
            
        status = status_data['status']
        
        if status == 'completed':
            return status_data['result']
        elif status == 'failed':
            error = status_data.get('error', {})
            raise Exception(f"Export failed: {error.get('message')}")
        
        # Update progress
        progress = status_data.get('progress', 0)
        step = status_data.get('current_step', 'Processing')
        print(f"Progress: {progress}% - {step}")
        
        # Wait with exponential backoff
        time.sleep(wait_interval)
        wait_interval = min(wait_interval * 1.2, max_interval)
    
    raise TimeoutError("Export timed out")
```

### 3. Async Polling for Multiple Exports

Monitor multiple exports simultaneously:

```python
import asyncio
import aiohttp

async def check_export_status_async(session, job_id):
    """Async version of status check"""
    url = f'https://api.hoox.video/v1/export/status/{job_id}'
    headers = {'Authorization': 'Bearer your_api_key'}
    
    async with session.get(url, headers=headers) as response:
        return await response.json()

async def monitor_multiple_exports(job_ids):
    """Monitor multiple exports simultaneously"""
    async with aiohttp.ClientSession() as session:
        while job_ids:
            # Check all remaining jobs
            tasks = [check_export_status_async(session, job_id) for job_id in job_ids]
            results = await asyncio.gather(*tasks)
            
            completed_jobs = []
            for i, result in enumerate(results):
                job_id = job_ids[i]
                status = result['status']
                
                if status == 'completed':
                    print(f"✅ Export {job_id} completed: {result['result']['video_url']}")
                    completed_jobs.append(job_id)
                elif status == 'failed':
                    print(f"❌ Export {job_id} failed: {result['error']['message']}")
                    completed_jobs.append(job_id)
                else:
                    progress = result.get('progress', 0)
                    print(f"⏳ Export {job_id}: {progress}%")
            
            # Remove completed jobs
            job_ids = [job_id for job_id in job_ids if job_id not in completed_jobs]
            
            if job_ids:
                await asyncio.sleep(5)  # Wait before next check
        
        print("All exports completed!")

# Usage
job_ids = ['export_123', 'export_456', 'export_789']
asyncio.run(monitor_multiple_exports(job_ids))
```

## Download Handling

### 1. Direct Download

Download the video file directly to your local storage:

```python
import requests
from urllib.parse import urlparse
import os

def download_video(video_url, save_path=None):
    """Download video from Hoox export URL"""
    
    # Generate filename if not provided
    if not save_path:
        parsed_url = urlparse(video_url)
        filename = os.path.basename(parsed_url.path) or 'video.mp4'
        save_path = f"./downloads/{filename}"
    
    # Create directory if it doesn't exist
    os.makedirs(os.path.dirname(save_path), exist_ok=True)
    
    # Download with streaming to handle large files
    response = requests.get(video_url, stream=True)
    response.raise_for_status()
    
    total_size = int(response.headers.get('content-length', 0))
    downloaded_size = 0
    
    with open(save_path, 'wb') as file:
        for chunk in response.iter_content(chunk_size=8192):
            if chunk:
                file.write(chunk)
                downloaded_size += len(chunk)
                
                # Show progress
                if total_size > 0:
                    progress = (downloaded_size / total_size) * 100
                    print(f"\rDownloading: {progress:.1f}%", end='', flush=True)
    
    print(f"\n✅ Video downloaded: {save_path}")
    return save_path

# Usage
video_url = "https://storage.hoox.video/exports/export_abcd1234.mp4"
local_path = download_video(video_url, "./my_videos/final_export.mp4")
```

### 2. Upload to Cloud Storage

Directly transfer the video to your cloud storage:

```python
import boto3
import requests

def upload_to_s3(video_url, bucket_name, s3_key):
    """Download video and upload directly to S3"""
    s3_client = boto3.client('s3')
    
    # Stream download and upload
    response = requests.get(video_url, stream=True)
    response.raise_for_status()
    
    # Upload to S3
    s3_client.upload_fileobj(
        response.raw,
        bucket_name,
        s3_key,
        ExtraArgs={'ContentType': 'video/mp4'}
    )
    
    print(f"✅ Video uploaded to S3: s3://{bucket_name}/{s3_key}")
    
    # Generate public URL if needed
    public_url = f"https://{bucket_name}.s3.amazonaws.com/{s3_key}"
    return public_url

# Usage after export completion
def complete_export_workflow(job_id):
    """Complete workflow: check status and upload to S3"""
    # Wait for completion
    result = wait_for_export_with_backoff(job_id)
    video_url = result['video_url']
    
    # Upload to your storage
    s3_url = upload_to_s3(
        video_url,
        'my-video-bucket',
        f'exports/{job_id}.mp4'
    )
    
    return s3_url
```

## Export Processing Steps

During export, you'll see various processing steps:

| Step | Description | Typical Duration |
|------|-------------|------------------|
| "Initializing export" | Setting up the export job | 1-3 seconds |
| "Preparing video" | Loading source video file | 2-5 seconds |
| "Converting format" | Changing aspect ratio if needed | 5-15 seconds |
| "Encoding video" | Creating final MP4 file | 15-60 seconds |
| "Uploading to storage" | Making file available for download | 2-5 seconds |
| "Export complete" | Process finished successfully | - |

## Error Handling

### Common Export Errors

```python
def handle_export_error(error_data):
    """Handle different types of export errors"""
    error_code = error_data.get('code', 'UNKNOWN_ERROR')
    error_message = error_data.get('message', 'Unknown error occurred')
    
    if error_code == 'ENCODING_FAILED':
        print("Video encoding failed. This might be due to:")
        print("- Corrupted source video")
        print("- Unsupported video format")
        print("- Resource limitations")
        print("Action: Try exporting again or contact support")
        
    elif error_code == 'FORMAT_CONVERSION_FAILED':
        print("Format conversion failed. This might be due to:")
        print("- Incompatible source format for target format")
        print("- Extreme aspect ratio changes")
        print("Action: Try a different target format")
        
    elif error_code == 'STORAGE_FAILED':
        print("Failed to upload to storage. This is usually temporary.")
        print("Action: Retry the export")
        
    else:
        print(f"Export error: {error_code} - {error_message}")
        print("Action: Contact support if this persists")

# Usage in status checking
def robust_export_monitoring(job_id):
    """Monitor export with comprehensive error handling"""
    try:
        result = wait_for_export_with_backoff(job_id)
        return result['video_url']
        
    except Exception as e:
        if 'Export failed:' in str(e):
            # Extract error from exception message
            print(f"Export failed: {e}")
            # Could implement retry logic here
        else:
            print(f"Monitoring error: {e}")
        return None
```

## URL Security and Expiration

<Warning>
**Important**: Download URLs are temporary and secure
- URLs expire after 24 hours
- URLs are signed and tied to your API key
- Don't share URLs publicly - download and store the files
- URLs cannot be used after expiration
</Warning>

```python
import time
from datetime import datetime, timedelta

def download_with_expiration_check(video_url, created_at):
    """Download video with expiration awareness"""
    
    # Parse creation timestamp
    created_time = datetime.fromisoformat(created_at.replace('Z', '+00:00'))
    expiration_time = created_time + timedelta(hours=24)
    current_time = datetime.now(tz=created_time.tzinfo)
    
    # Check if URL is still valid
    if current_time >= expiration_time:
        raise Exception("Download URL has expired. Please re-export the video.")
    
    # Calculate time until expiration
    time_remaining = expiration_time - current_time
    hours_remaining = time_remaining.total_seconds() / 3600
    
    print(f"⏰ Download URL expires in {hours_remaining:.1f} hours")
    
    if hours_remaining < 1:
        print("⚠️  URL expires soon! Download immediately.")
    
    return download_video(video_url)
```

## Complete Export Workflow

Here's a complete example that combines all best practices:

```python
class ExportManager:
    def __init__(self, api_key):
        self.api_key = api_key
        self.base_url = 'https://api.hoox.video/v1'
        
    def start_export(self, video_id, format='vertical', webhook_url=None):
        """Start video export"""
        payload = {'video_id': video_id, 'format': format}
        if webhook_url:
            payload['webhook_url'] = webhook_url
            
        response = requests.post(
            f'{self.base_url}/export/start',
            headers={'Authorization': f'Bearer {self.api_key}'},
            json=payload
        )
        response.raise_for_status()
        return response.json()
    
    def check_status(self, job_id):
        """Check export status"""
        response = requests.get(
            f'{self.base_url}/export/status/{job_id}',
            headers={'Authorization': f'Bearer {self.api_key}'}
        )
        response.raise_for_status()
        return response.json()
    
    def wait_and_download(self, job_id, save_path=None):
        """Complete workflow: wait for export and download"""
        print(f"Starting export monitoring for job: {job_id}")
        
        # Wait for completion
        result = wait_for_export_with_backoff(job_id)
        video_url = result['video_url']
        
        print(f"✅ Export completed! Downloading...")
        
        # Download video
        local_path = download_video(video_url, save_path)
        
        return {
            'local_path': local_path,
            'video_url': video_url,
            'cost': result['cost'],
            'export_data': result
        }

# Usage
export_manager = ExportManager('your_api_key')

# Start export
export_job = export_manager.start_export('vid_xyz789', format='vertical')
job_id = export_job['job_id']

# Wait and download
result = export_manager.wait_and_download(job_id, './downloads/my_video.mp4')
print(f"Video saved to: {result['local_path']}")
```

## Next Steps

<CardGroup cols={2}>
  <Card title="Webhook Integration" href="/webhooks/overview" icon="webhook">
    Set up automatic notifications for export completion
  </Card>
  <Card title="API Reference" href="/api-reference/export/status" icon="code">
    Complete API documentation for status endpoints
  </Card>
</CardGroup>