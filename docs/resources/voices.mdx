---
title: "Voice Resources"
description: "Discover and use available voices for video generation"
---

## Overview

Voices are essential components for creating engaging videos. Hoox provides a wide variety of high-quality voices in multiple languages, plus the ability to use custom voices for your brand.

## Available Voices

Your available voices depend on your subscription plan:

<CardGroup cols={4}>
  <Card title="Free Plan" icon="gift">
    **3 voices**
    - English only
    - Basic quality
    - Standard accents
  </Card>
  <Card title="Start Plan" icon="rocket">
    **15+ voices**
    - English + French
    - High quality
    - Multiple accents
  </Card>
  <Card title="Pro Plan" icon="star">
    **50+ voices**
    - 10+ languages
    - Premium quality
    - Custom voice upload
  </Card>
  <Card title="Enterprise" icon="building">
    **All voices**
    - All languages
    - Voice cloning
    - Unlimited custom voices
  </Card>
</CardGroup>

## Getting Available Voices

Use the resources API to retrieve voices available for your account:

```python
import requests

def get_available_voices(language=None, gender=None, tags=None):
    """Get available voices with optional filters"""
    url = "https://api.hoox.video/v1/resources/voices"
    headers = {"Authorization": "Bearer your_api_key"}
    
    params = {}
    if language:
        params["language"] = language
    if gender:
        params["gender"] = gender
    if tags:
        params["tags"] = ",".join(tags) if isinstance(tags, list) else tags
    
    response = requests.get(url, headers=headers, params=params)
    response.raise_for_status()
    
    return response.json()["voices"]

# Get all voices
all_voices = get_available_voices()
print(f"Available voices: {len(all_voices)}")

# Filter for English female voices
english_female = get_available_voices(language="en", gender="female")
print(f"English female voices: {len(english_female)}")

# Filter by tags
professional_voices = get_available_voices(tags=["professional", "news"])
print(f"Professional voices: {len(professional_voices)}")
```

## Voice Categories

### By Language

<Tabs>
  <Tab title="English">
    **Accents Available:**
    - US English (Standard American)
    - UK English (British Received Pronunciation)
    - Canadian English
    - Australian English
    
    **Common Use Cases:**
    - Global business content
    - Educational videos
    - Marketing materials
    - News and media
  </Tab>
  
  <Tab title="French">
    **Accents Available:**
    - French (France)
    - Canadian French (Quebec)
    
    **Common Use Cases:**
    - French market content
    - Educational materials
    - Corporate communications
    - Cultural content
  </Tab>
  
  <Tab title="Spanish">
    **Accents Available:**
    - Spanish (Spain)
    - Latin American Spanish
    - Mexican Spanish
    
    **Common Use Cases:**
    - Hispanic market expansion
    - Educational content
    - Tourism and travel
    - E-commerce
  </Tab>
  
  <Tab title="Other Languages">
    **Available Languages:**
    - German (DE)
    - Italian (IT)
    - Portuguese (PT)
    - Dutch (NL)
    - Japanese (JA)
    - Mandarin Chinese (ZH)
    
    **Expanding regularly** with new languages added based on demand.
  </Tab>
</Tabs>

### By Gender and Style

<CardGroup cols={2}>
  <Card title="Male Voices" icon="user">
    **Characteristics:**
    - Authoritative and confident
    - Deep, resonant tones
    - Professional and documentary styles
    
    **Best For:**
    - Corporate presentations
    - Technical explanations
    - Documentary narration
    - Executive communications
  </Card>
  
  <Card title="Female Voices" icon="user">
    **Characteristics:**
    - Warm and engaging
    - Clear articulation
    - Friendly and approachable
    
    **Best For:**
    - Educational content
    - Customer support
    - Marketing materials
    - Lifestyle content
  </Card>
</CardGroup>

### By Style and Tone

Voice tags help you find the perfect match for your content:

| Tag | Description | Use Cases |
|-----|-------------|-----------|
| `professional` | Business-appropriate, formal tone | Corporate videos, presentations |
| `friendly` | Warm, approachable, conversational | Social media, customer engagement |
| `authoritative` | Confident, commanding presence | News, documentation, training |
| `casual` | Relaxed, informal, conversational | Lifestyle content, personal brands |
| `energetic` | Upbeat, enthusiastic, dynamic | Marketing, sports, entertainment |
| `warm` | Comforting, empathetic, nurturing | Healthcare, education, support |
| `clear` | Crisp articulation, easy to understand | Instructions, tutorials, accessibility |
| `deep` | Lower pitch, resonant voice | Luxury brands, automotive, technology |

## Voice Selection Best Practices

### 1. Match Voice to Content Type

```python
def recommend_voice(content_type, target_audience="general"):
    """Recommend voice based on content type"""
    
    voice_filters = {
        "business": {"tags": ["professional", "authoritative"]},
        "education": {"tags": ["clear", "friendly"]},
        "marketing": {"tags": ["energetic", "engaging"]},
        "support": {"tags": ["warm", "helpful"]},
        "news": {"tags": ["authoritative", "professional"]},
        "lifestyle": {"tags": ["casual", "friendly"]},
        "tutorial": {"tags": ["clear", "patient"]},
        "entertainment": {"tags": ["energetic", "fun"]}
    }
    
    filters = voice_filters.get(content_type, {"tags": ["professional"]})
    
    # Add demographic considerations
    if target_audience == "young_adults":
        filters["tags"].append("energetic")
    elif target_audience == "seniors":
        filters["tags"].extend(["clear", "warm"])
    elif target_audience == "professionals":
        filters["tags"].append("authoritative")
    
    return get_available_voices(tags=filters["tags"])

# Usage
business_voices = recommend_voice("business", "professionals")
education_voices = recommend_voice("education", "young_adults")
```

### 2. Consider Your Brand Voice

Align voice selection with your brand personality:

```python
class BrandVoiceSelector:
    def __init__(self, brand_personality):
        self.brand_personality = brand_personality
        
        # Define brand voice mappings
        self.personality_map = {
            "luxury": {"tags": ["authoritative", "sophisticated"], "gender": "female"},
            "tech_startup": {"tags": ["energetic", "modern"], "gender": "any"},
            "healthcare": {"tags": ["warm", "professional", "clear"], "gender": "any"},
            "education": {"tags": ["clear", "patient", "friendly"], "gender": "any"},
            "finance": {"tags": ["authoritative", "professional"], "gender": "male"},
            "lifestyle": {"tags": ["casual", "friendly", "warm"], "gender": "female"},
            "sports": {"tags": ["energetic", "dynamic"], "gender": "male"},
            "beauty": {"tags": ["warm", "sophisticated"], "gender": "female"}
        }
    
    def get_brand_voices(self, language="en"):
        """Get voices that match brand personality"""
        voice_criteria = self.personality_map.get(self.brand_personality, 
                                                  {"tags": ["professional"]})
        
        filters = {"language": language}
        filters.update(voice_criteria)
        
        return get_available_voices(**filters)
    
    def select_primary_voice(self, language="en"):
        """Select the primary brand voice"""
        voices = self.get_brand_voices(language)
        
        if voices:
            # Return the first voice as primary
            return voices[0]
        else:
            # Fallback to any professional voice
            return get_available_voices(language=language, tags=["professional"])[0]

# Usage
brand_selector = BrandVoiceSelector("tech_startup")
primary_voice = brand_selector.select_primary_voice("en")
print(f"Primary brand voice: {primary_voice['name']} ({primary_voice['id']})")
```

### 3. Test Voice Quality

Always preview voices before committing to video generation:

```python
def preview_voice_samples(voice_ids, sample_text="Hello, this is a voice preview."):
    """Generate audio previews for voice comparison"""
    import pygame  # For audio playback
    
    for voice_id in voice_ids:
        # Get voice info
        voices = get_available_voices()
        voice = next((v for v in voices if v['id'] == voice_id), None)
        
        if not voice:
            print(f"Voice {voice_id} not found")
            continue
            
        print(f"\n🎤 {voice['name']} ({voice['language']}, {voice['gender']})")
        print(f"   Tags: {', '.join(voice['tags'])}")
        print(f"   Preview: {voice['preview']}")
        
        # Play preview (you can implement actual audio playback)
        choice = input("   Play preview? (y/n): ")
        if choice.lower() == 'y':
            # Implementation would play the preview URL
            print("   Playing preview...")

# Usage
candidate_voices = ["voice_en_us_female_sarah", "voice_en_uk_male_james"]
preview_voice_samples(candidate_voices)
```

## Custom Voices

### For Pro and Enterprise Plans

Upload your own voice samples to create custom branded voices:

#### Requirements for Custom Voices

<Accordion title="Audio Quality Requirements">
  - **Format**: WAV, MP3, or FLAC
  - **Sample Rate**: 44.1kHz or 48kHz
  - **Bit Depth**: 16-bit minimum, 24-bit preferred
  - **Duration**: Minimum 2 minutes of speech
  - **Quality**: Studio-quality recording with minimal background noise
</Accordion>

<Accordion title="Content Requirements">
  - **Varied sentences**: Include questions, statements, and emotional variations
  - **Clear pronunciation**: Avoid mumbling or unclear speech
  - **Consistent pace**: Maintain steady speaking rhythm
  - **Natural intonation**: Include natural speech patterns and pauses
</Accordion>

<Accordion title="Technical Requirements">
  - **Single speaker**: Only one person speaking
  - **Consistent environment**: Same acoustic conditions throughout
  - **No background music**: Clean speech only
  - **Proper levels**: Avoid clipping or too-quiet recordings
</Accordion>

#### Custom Voice Creation Process

1. **Preparation**: Record high-quality voice samples
2. **Upload**: Submit samples via dashboard or API
3. **Processing**: AI voice cloning (24-48 hours)
4. **Review**: Quality assessment and approval
5. **Availability**: Voice appears in your resources list

```python
def check_custom_voices():
    """Check for custom voices in your account"""
    voices = get_available_voices()
    custom_voices = [v for v in voices if 'custom' in v.get('tags', [])]
    
    print(f"Custom voices available: {len(custom_voices)}")
    for voice in custom_voices:
        print(f"- {voice['name']} ({voice['id']})")
    
    return custom_voices

# Usage
my_custom_voices = check_custom_voices()
```

## Voice Usage in Generation

### Basic Usage

```python
def create_video_with_voice(script, voice_id, avatar_id=None):
    """Create video using specific voice"""
    payload = {
        "script": script,
        "voice_id": voice_id
    }
    
    if avatar_id:
        payload["avatar_id"] = avatar_id
    
    response = requests.post(
        "https://api.hoox.video/v1/generation/start",
        headers={"Authorization": "Bearer your_api_key"},
        json=payload
    )
    
    return response.json()

# Usage
job = create_video_with_voice(
    script="Welcome to our new product launch!",
    voice_id="voice_en_us_female_sarah",
    avatar_id="avatar_business_woman_1"
)
```

### Voice with Custom Audio

For ultimate control, provide your own audio file:

```python
def create_video_with_custom_audio(avatar_id, voice_url):
    """Create video with custom voice file"""
    payload = {
        "voice_url": voice_url,  # URL to your audio file
        "avatar_id": avatar_id
    }
    
    response = requests.post(
        "https://api.hoox.video/v1/generation/start",
        headers={"Authorization": "Bearer your_api_key"},
        json=payload
    )
    
    return response.json()

# Usage
job = create_video_with_custom_audio(
    avatar_id="avatar_business_woman_1",
    voice_url="https://yourdomain.com/audio/custom_narration.mp3"
)
```

## Multi-Language Content Strategy

### Language-Specific Voice Selection

```python
class MultiLanguageVoiceManager:
    def __init__(self, api_key):
        self.api_key = api_key
        self.language_preferences = {
            "en": {"gender": "female", "tags": ["professional", "clear"]},
            "fr": {"gender": "female", "tags": ["elegant", "professional"]},
            "es": {"gender": "male", "tags": ["warm", "authoritative"]},
            "de": {"gender": "male", "tags": ["professional", "clear"]}
        }
    
    def get_voice_for_language(self, language):
        """Get the best voice for a specific language"""
        preferences = self.language_preferences.get(language, {})
        voices = get_available_voices(language=language, **preferences)
        
        if voices:
            return voices[0]  # Return the first matching voice
        else:
            # Fallback to any voice in that language
            all_voices = get_available_voices(language=language)
            return all_voices[0] if all_voices else None
    
    def create_multilingual_content(self, scripts_by_language, avatar_id):
        """Create videos in multiple languages"""
        jobs = {}
        
        for language, script in scripts_by_language.items():
            voice = self.get_voice_for_language(language)
            
            if voice:
                job = create_video_with_voice(script, voice['id'], avatar_id)
                jobs[language] = job['job_id']
                print(f"✅ Started {language} video with voice: {voice['name']}")
            else:
                print(f"❌ No voice available for language: {language}")
        
        return jobs

# Usage
voice_manager = MultiLanguageVoiceManager("your_api_key")

scripts = {
    "en": "Welcome to our global platform!",
    "fr": "Bienvenue sur notre plateforme mondiale !",
    "es": "¡Bienvenido a nuestra plataforma global!",
    "de": "Willkommen auf unserer globalen Plattform!"
}

multilingual_jobs = voice_manager.create_multilingual_content(
    scripts, 
    "avatar_business_woman_1"
)
```

## Troubleshooting Common Issues

### Voice Not Available

```python
def safe_voice_selection(preferred_voice_id, fallback_criteria):
    """Safely select a voice with fallback options"""
    # Try preferred voice first
    all_voices = get_available_voices()
    preferred_voice = next((v for v in all_voices if v['id'] == preferred_voice_id), None)
    
    if preferred_voice:
        return preferred_voice
    
    print(f"⚠️  Preferred voice {preferred_voice_id} not available")
    
    # Try fallback criteria
    fallback_voices = get_available_voices(**fallback_criteria)
    if fallback_voices:
        selected = fallback_voices[0]
        print(f"✅ Using fallback voice: {selected['name']} ({selected['id']})")
        return selected
    
    # Ultimate fallback - any available voice
    if all_voices:
        ultimate_fallback = all_voices[0]
        print(f"⚠️  Using ultimate fallback: {ultimate_fallback['name']}")
        return ultimate_fallback
    
    raise Exception("No voices available!")

# Usage
voice = safe_voice_selection(
    "voice_en_us_female_premium_sarah",  # Preferred but might not exist
    {"language": "en", "gender": "female", "tags": ["professional"]}  # Fallback
)
```

### Performance Optimization

```python
class VoiceCacheManager:
    def __init__(self, api_key):
        self.api_key = api_key
        self._cache = {}
        self._cache_timestamp = None
        self.cache_duration = 3600  # 1 hour
    
    def get_voices(self, **filters):
        """Get voices with caching"""
        import time
        
        cache_key = str(sorted(filters.items()))
        current_time = time.time()
        
        # Check if cache is valid
        if (self._cache_timestamp and 
            current_time - self._cache_timestamp < self.cache_duration and
            cache_key in self._cache):
            return self._cache[cache_key]
        
        # Fetch fresh data
        voices = get_available_voices(**filters)
        
        # Update cache
        self._cache[cache_key] = voices
        self._cache_timestamp = current_time
        
        return voices
    
    def clear_cache(self):
        """Clear voice cache"""
        self._cache = {}
        self._cache_timestamp = None

# Usage
voice_cache = VoiceCacheManager("your_api_key")

# These calls will use cached data after the first request
english_voices = voice_cache.get_voices(language="en")
female_voices = voice_cache.get_voices(gender="female")
professional_voices = voice_cache.get_voices(tags=["professional"])
```

## Next Steps

<CardGroup cols={2}>
  <Card title="Avatar Resources" href="/resources/avatars" icon="user">
    Learn about available avatars to pair with your voices
  </Card>
  <Card title="Video Generation" href="/video-generation/start-generation" icon="play">
    Start creating videos with your selected voices
  </Card>
</CardGroup>